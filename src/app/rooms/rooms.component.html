<!-- binding in angular -->
<!-- the name is binded through interpolation binding. -->
<!-- <h1>welcome to {{hotelName}}</h1> -->

<app-header></app-header>

<!-- this is an example of property binding where we can bind data using any html property which is valid! -->
<div [hidden]="hideRooms">
  <p>No. of rooms</p>
  <div [innerHTML]="numberOfRoomsAvailable"></div>
</div>

<!--Null collision operator and optional chaining -->
<!-- {{room?.availableRooms ?? 'No Rooms'}} -->
<div *ngIf="selectedRoom">
  {{selectedRoom | json}}
</div>
<!-- component communication -->
<h1>{{totalByte}} loaded</h1>
<div><button (click)="addRoom()">ADD Room</button></div>

<!-- *ngIf Directive -->
<div *ngIf="hideRooms">
  <app-room-list
    [rooms]="roomList"
    (selectedRoom)="selectRoom($event)"
  ></app-room-list>
  <!-- {{roomList}} -->
</div>

<!-- event binding:  -->
<button (click)="toggle()">Toggle</button>
<button (click)="editRoom()">Edit Room</button>
<button (click)="deleteRoom()">Delete Room</button>

<!-- Directives:
Directives are used to change the behaviour and appearance of your DOM element. 
Directives can implement all lifecycle hooks
Directives can not have template  -->

<!-- types of Directives
1. Structural : costlier --they change the behaviour of DOM which may cause performance issues.
2. Attribute : -->

<!-- built in directives

*ngIf  - this * represent the structural Directive...these are used to add/Remove elmenets in the DOM

*ngFor  - this * represent the structural Directive...these are used to add/Remove elmenets in the DOM

*ngSwitch - this * represent the structural Directive...these are used to add/Remove elmenets in the DOM

ngClass - this is attribute directive , these help in modifying the elements in the DOM

ngStyle - this is attribute directive , these help in modifying the elements in the DOM -->

<!-- ***PIPES***
1. Pipes are used for data transformation
2. Pipes don't change actual object -->

<!-- ***BUILT_IN Pipes***
1. DatePipe
2. UpperCasePipe
3. LowerCasePipe
4. CurrencyPipe
5. DecimalPipe
6. PercenPipe
7. JsonPipe
8. SlicePipe
9. AsyncPipe
10. titlecasePipe -->

<!-- ***LifeCycle Hooks*** 
#  Components instance has lifecycle hooks which can help you to hook into different events on components.
#  Lifecycle ends when component is detroyed! -->

<!-- Certain available Lifecycle Hooks are: -->
<!-- 
  1. ngOnChanges -- changedetectionstrategy:can only be applied to the component which have input decorator.
  2. ngOnInit
  3. ngDoCheck -- must avoid, expensive, hardly using, check every change in the entire page.
  4. ngAfterContentInit -- <ng-content> is used here
  5. ngAfterContentChecked
  6. ngAfterViewInit -- used @viewchild and @viewchilden
  7. ngAfterViewChecked
  8. ngOnDestroy -- end of the the component

  NOTE:
  ngonchanges and ngdocheck should not be applied together on the same compoennt because both are goint to do the same task -- detect changes**
 -->

<!-- ***component communication-- ngOnInit ***-->

<!-- 
# component communication goes hand in hand with lifecycle hooks.

# The Scenario where two or more components needs to interact with eachother is know as component communication

# there are multiple ways to achieve the component communication

#we can communicate with other component using three ways

#1) @Input() and @Output() decorator
#2) Services Class
#3) @viewChild and @contentChild decorator: 
#)  EventEmitter class  //facilitates communication betweeen component

  -->

<!-- ***Change Detection --  ngOnChanges*** -->
<!-- 
  by default its "default..and other is push"
  changeDetection:ChangeDetectionStrategy.push/simply nothing to mak default.......
 -->

<!-- ***Contect Projection***-->
<!--   
  <ng-content></ng-content> is used here with content projection!
  we can provide a fixed design..and then just write other components!
  -->

<!-- ***Depending Injection*** -->
<!-- 
   # DI not available in other frameworks..
   # Dependencies are services or objects needed by classes to perform some function.
   # It is a design pattern.
   # Angular has built-in dependency injection support.
    
   DI Provider:
   # value providers - with value based provider we use :@injectable, @inject, Injectiontoken instead of directly accesing API , localstorage, services, interfaces.

   # class based provider  
   # factory
   -->

<!-- ***Services*** -->
<!-- 
   ProvidedIn: root and any
    #business logic should go into services.

    -->
<!-- *** Resolution Modifiers/ Decorators: which we use with services*** -->
<!-- 
  # Self
  # SkipSelf
  # Optional
  # Host
 -->

<!-- Component interaction using services:

  # sharing data between multiple components
  #sharing data within App

 -->
<!-- Angular Http and observables : interactt with API's -->
<!-- 
  #introduction
  #setting up HttpClient
    -> we need to import HttpClientModule from @angular/common/http
    -> once module is imported we can inject HttpClient Service.
  #using HttpClient service
  #RxJx , observables and streams --pull and push based architecture
  #http methods
  #RxJx operators and their types:
    =>ShareReplay -- we cache data only once!
    =>CatchError--  AsyncPipe , used with handling exception or catching errors
    =>Map operators - modify data 
  # subject - rxjs element which is an observer as well as observable
  #http interceptors
  #APP_Initializers

  =>in enterprise apps, you need to interact with API
  =>HttpClient is service provided by angulat to interact with API;s
  =>HttpClient internally uses RxJS
  =>HttpvClient returns an Observable<Response> object    
  -->

<!-- HTTP interceptors and APP_INITIALIZERS -->
<!--
  =>Allows us to interpret request
  =>we can change data and add HttpRequestHeaders
  =>HTTP-interceptors can modify the request and response but they can't modify the original request/response , they have to clone the req/res.
  
  =>APP_INITIALIZERS allows you to injects function  as application startup ---it is used to load the data before the app is initialised.
 -->

 <!-- angular Router -->
 <!--
  =>Router is a core feature of Angular application
  =>We have two ways to navigate through the app
  1) Programmatic navigation
  2) Declarative navigation
  =>Introduction
    --Provides the functionality to add routes
    --Developers can configure all the routes at front-end
    --Provides SPA functionality
    --Feature to add nested routes

  =>setp router
    --Import RouterModule
    --forRoot method allows us to add multiple route config
    --Default route
    --Dynamic route
    --Wild card route -> 404 pagess

  =>Using ActivatedRoute Service
    --Allows to read the router data.
    --Allows access to snapshot data.
    --Allows to access data from Route config.   
    --params
    --paramsmap

  =>using Router Service
  =>Feature Module and Routing
  =>Lazy loading modules
  =>Nested Routing and Child routes
  =>Route Guards
 -->

 <!-- forms- ->two types: template driven forms and reactive forms -->
 <!-- 
  Template driven forms:
   =>setting up template driven forms
      --import formsModule to module
      --in template driven forms we create forms using html tags
      --good for developers who like to have more control using html
      --use ngModel for 2 way data binding
      
   =>validating forms
   =>submit and reset forms
   =>custom pipe demo with forms
   => writing custom directive
   =>writing custom validator
  -->

  